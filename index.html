<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>RPG Multiplayer with Dungeons</title>
<style>
body{margin:0;overflow:hidden;background:#1a1a1a;font-family:sans-serif;color:white}
canvas{display:block;}
#chat{position:absolute;bottom:10px;left:10px;width:300px;max-height:200px;overflow-y:auto;background: rgba(0,0,0,0.6);padding:5px;border-radius:5px;}
#chat input{width:100%;box-sizing:border-box;border:none;padding:5px;border-radius:3px;}
.message{margin:2px 0;}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="chat">
  <div id="messages"></div>
  <input id="chatInput" placeholder="Type a message and press Enter">
</div>
<script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
<script>
const canvas=document.getElementById("gameCanvas"), ctx=canvas.getContext("2d");
function resize(){canvas.width=window.innerWidth; canvas.height=window.innerHeight;}
window.addEventListener("resize",resize); resize();

const keys={}, speed=3;
window.addEventListener("keydown",e=>keys[e.key]=true);
window.addEventListener("keyup",e=>keys[e.key]=false);

// Gun setup
const gun=Gun({peers:['https://gun-manhattan.herokuapp.com/gun']});
const playersRef=gun.get('players');
const worldsRef=gun.get('worlds');
const dungeonsRef=gun.get('dungeons');
const enemiesRef=gun.get('enemies');
const lootRef=gun.get('loot');
const inventoryRef=gun.get('inventory');
const chatRef=gun.get('chat');

const localId=Math.random().toString(36).substr(2,9);
const localName=prompt("Enter your name")||"Player"+localId.slice(0,4);
// <<< FIX 1: Added the 'name: localName' property
const localPlayer={name:localName, x:400,y:300,size:30,color:"#"+Math.floor(Math.random()*16777215).toString(16),health:100,score:0,currentLocation:{type:"world",id:"world1"}};
playersRef.get(localId).put(localPlayer);

const players={}, enemies={}, loot={}, inventory={}, worlds={}, dungeons={};

// Chat
const chatInput=document.getElementById("chatInput");
const messagesDiv=document.getElementById("messages");
chatInput.addEventListener("keydown",e=>{
  if(e.key==="Enter" && chatInput.value.trim()!==""){
    // localPlayer.name will now be correct thanks to FIX 1
    chatRef.set({id:localId,msg:chatInput.value,name:localPlayer.name});
    chatInput.value="";
  }
});
chatRef.map().on(data=>{
  if(!data) return;
  const div=document.createElement("div"); div.className="message";
  div.textContent=`${data.name||"Player"}: ${data.msg}`;
  messagesDiv.appendChild(div); messagesDiv.scrollTop=messagesDiv.scrollHeight;
});

// Listen for multiplayer updates
playersRef.map().on((data,id)=>{ if(!data) return; players[id]=data; });
enemiesRef.map().on((data,id)=>{ if(!data) return; enemies[id]=data; });
lootRef.map().on((data,id)=>{ if(!data) return; loot[id]=data; });
worldsRef.map().on((data,id)=>{ if(!data) return; worlds[id]=data; });
dungeonsRef.map().on((data,id)=>{ if(!data) return; dungeons[id]=data; });
inventoryRef.map().on((data,id)=>{ if(!data) return; inventory[id]=data; });

// Helper
function distance(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}
function checkCollision(x,y,size,objs){for(const o of objs)if(x+size/2>o.x&&x-size/2<o.x+o.w&&y+size/2>o.y&&y-size/2<o.y+o.h)return true;return false;}
function addMessage(msg){const d=document.createElement("div");d.className="message";d.textContent=msg;messagesDiv.appendChild(d);messagesDiv.scrollTop=messagesDiv.scrollHeight;}
function respawn(p){p.x=400;p.y=300;p.health=100;}

// === World/Dungeon Setup
function setupWorld(id){
  if(!worlds[id]){
    worldsRef.get(id).put({obstacles:[{x:500,y:500,w:200,h:50}],shops:[{x:300,y:300,items:[{name:"Potion",cost:5}]}],dungeonEntrance:{x:800,y:800,dungeonId:"dungeon1"}});
  }
}
function setupDungeon(id){
  if(!dungeons[id]){
    dungeonsRef.get(id).put({obstacles:[{x:100,y:100,w:100,h:50}],enemies:[{x:200,y:200,size:25,health:50}],loot:[]});
  }
}
setupWorld("world1"); setupDungeon("dungeon1");

// === Game Update ===
function update(){
  let loc = localPlayer.currentLocation;
  let currentObstacles = [];
  let shops = [];
  if(loc.type==="world"){
    const w = worlds[loc.id]; if(w){currentObstacles=w.obstacles||[]; shops=w.shops||[];}
    // Enter dungeon
    if(w && w.dungeonEntrance && distance(localPlayer,w.dungeonEntrance)<30 && keys["e"]){
      localPlayer.currentLocation={type:"dungeon",id:w.dungeonEntrance.dungeonId};
      localPlayer.x=100; localPlayer.y=100;
      addMessage("Entered Dungeon!");
    }
  }else if(loc.type==="dungeon"){
    const d = dungeons[loc.id]; if(d){currentObstacles=d.obstacles||[];}
  }

  // Movement
  let nx=localPlayer.x, ny=localPlayer.y;
  if(keys["w"])ny-=speed;if(keys["s"])ny+=speed;if(keys["a"])nx-=speed;if(keys["d"])nx+=speed;
  if(!checkCollision(nx,ny,localPlayer.size,currentObstacles)){localPlayer.x=nx; localPlayer.y=ny;}

  playersRef.get(localId).put(localPlayer);
}

// === Draw ===
function draw(){
  const camX=localPlayer.x-canvas.width/2, camY=localPlayer.y-canvas.height/2;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Draw world/dungeon obstacles
  let loc = localPlayer.currentLocation;
  let obs = [];
  // <<< FIX 3: Create an array to hold enemies from dungeon data
  let dungeonEnemies = [];
  if(loc.type==="world"){ let w = worlds[loc.id]; if(w) obs=w.obstacles||[]; }  
  else if(loc.type==="dungeon"){ 
    let d = dungeons[loc.id]; 
    if(d) {
      obs=d.obstacles||[]; 
      dungeonEnemies = d.enemies||[]; // <<< FIX 3: Get enemies from dungeon data
    }
  }
  ctx.fillStyle="#555"; for(const o of obs)ctx.fillRect(o.x-camX,o.y-camY,o.w,o.h);

  // Draw shops/dungeon entrance
  if(loc.type==="world"){ let w = worlds[loc.id]; if(w){
    ctx.fillStyle="cyan"; for(const s of w.shops)ctx.fillRect(s.x-10-camX,s.y-10-camY,20,20);
    if(w.dungeonEntrance) ctx.fillStyle="purple", ctx.fillRect(w.dungeonEntrance.x-10-camX,w.dungeonEntrance.y-10-camY,20,20);
  }}

  // <<< FIX 3: Draw the enemies we found in the dungeon data
  ctx.fillStyle="red";
  for(const e of dungeonEnemies){
    ctx.fillRect(e.x-e.size/2-camX, e.y-e.size/2-camY, e.size, e.size);
    // Draw simple health bar
    ctx.fillStyle="#f00"; ctx.fillRect(e.x-e.size/2-camX, e.y-e.size/2-10-camY, e.size*(e.health/50), 3);
    ctx.strokeStyle="#000"; ctx.strokeRect(e.x-e.size/2-camX, e.y-e.size/2-10-camY, e.size, 3);
  }

  // Players
  for(const id in players){
    const p=players[id];
    // <<< FIX 2: Changed unreliable JSON.stringify to a robust property check
    if(p.currentLocation && p.currentLocation.type === localPlayer.currentLocation.type && p.currentLocation.id === localPlayer.currentLocation.id){
      ctx.fillStyle=p.color; ctx.fillRect(p.x-p.size/2-camX,p.y-p.size/2-camY,p.size,p.size);
      ctx.fillStyle="red"; ctx.fillRect(p.x-15-camX,p.y-p.size/2-10-camY,30*(p.health/100),5);
      ctx.strokeStyle="black"; ctx.strokeRect(p.x-15-camX,p.y-p.size/2-10-camY,30,5);
      ctx.fillStyle="white"; ctx.font="12px sans-serif"; 
      // This will now display correctly thanks to FIX 1
      ctx.fillText(`${p.name} (Score:${p.score})`,p.x-15-camX,p.y-p.size/2-15-camY);
    }
  }
}

function loop(){update();draw();requestAnimationFrame(loop);}
loop();
</script>
</body>
</html>
